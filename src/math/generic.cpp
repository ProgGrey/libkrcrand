#include "../../headers/math.hpp"
#include <cfloat>
#include <cmath>
#include <cstdint>
#include <cstring>

double horner(double x, const double *coefs, uint_fast8_t n)
{
    double val = coefs[0];
    for (uint_fast8_t k = 1; k < n; k++) {
        val = fma(x, val,  coefs[k]);
    }
    return val;
}

double horner1(double x, const double* coefs, uint_fast8_t n)
{
    double val = x + coefs[0];
    for (uint_fast8_t k = 1; k < n; k++) {
        val = fma(x, val, coefs[k]);
    }
    return val;
}

namespace krcrand{

double uniform01(uint64_t a)
{
    return double(a)*5.4210108624275221703e-20;
}


double uniform01_exclude0(uint64_t a)
{
    return fma(double(a), 5.4210108624275221703e-20, 5.4210108624275221700e-20);
}

// The code for log function below is based on algorithm from Cephes 2.8 math library by 
// Stephen L. Moshier 1984, 1995, 2000 - http://www.netlib.org/cephes/
// Max relative error is 1.523918708144333e-16 for normal numbers and 1.039444891344354e-16
// for subnormals (10^10 test runs).
double unsafe_log(double x)
{
    //Subnormal numbers correction. Max rel. error is 1.039444891344354e-16 for 10^10 test runs.
    double addition = 0;
    if (x <= 2.2250738585072009e-308) {
        x *= 4503599627370496.0;
        addition = -36.0436533891171560897;
    }
    //x=2.2e-308
    // Log(2)
    static const double loge2_p = 0.693359375;
    static const double loge2_n = 2.121944400546905827679E-4;
    //const double loge2 = 0.693147180559945309417;
    //sqrt(2)/2
    static const double sqrt2b2 = 7.07106781186547524400E-1;
    //Constants for polynom
    static const double a[6] = {1.01875663804580931796E-4, 4.97494994976747001425E-1, 4.70579119878881725854E0, 1.44989225341610930846E1,
                                1.79368678507819816313E1, 7.70838733755885391666E0 };
    static const double b[6] = {1.12873587189167450590E1, 4.52279145837532221105E1, 8.29875266912776603211E1, 7.11544750618563894466E1, 
                                2.31251620126765340583E1 };// first cooeficient is 1 here
    // unpack double
    uint64_t code;
    memcpy(&code, &x, sizeof(double));
    uint64_t man_code = (code & 0x000FFFFFFFFFFFFF) | 0x3FE0000000000000;
    uint64_t exp_code = code >> 52 | 0x4330000000000000;
    double man;
    double exp;
    memcpy(&man, &man_code, sizeof(double));
    memcpy(&exp, &exp_code, sizeof(double));
    exp = exp - 1022 - 4503599627370496.0;
    // Fix interval
    if (man < sqrt2b2) {
        man += man;
        exp--;
    }
    man -= 1;
    //Rational approximation
    double num = horner(man, a, 6);
    double den = horner1(man, b, 5);

    double man2 = man * man;

    double res = fma(man, (man2 * num / den), -loge2_n * exp);
    //Splitting increases precision:
    //res -= loge2_n * exp;
    res = fma(-0.5, man2, res);
    //res -= 0.5 * man2;
    res += man;
    //res += loge2 * exp; Using property of logarithms for powers.
    //res += loge2_p * exp;
    res = fma(loge2_p, exp, res);
    return res + addition;
}


/* The code below for LambertW function is based on Darko Veberic realization of method from
  Toshio Fukushima, "Precise and fast computation of Lambert W-functions without transcendental 
  function evaluations", J. Comp. Appl. Math. 244 (2013) 77-89. The author distributes it under 
  the terms of the BSD-2 clause license.*/
inline double LambertWSeries(double p)
{
    static const double qq[21] = {-0.0000581136075044138168, 0.0000866503580520812717, -0.000129574266852748819, 0.000194387276054539318, -0.000292677224729627445, 
                                0.000442473061814620910, -0.000672061631156136204, 0.00102626332050760715, -0.00157693034468678425, 0.00244087799114398267, 
                                -0.00381129803489199923, 0.00601454325295611786, -0.00961689202429943171, 0.0156356325323339212, -0.0259847148736037625, 0.0445023148148148148,
                                -0.0796296296296296296, 0.152777777777777778, -0.333333333333333333, 1.0, -1.0};
    double ap = abs(p);
    if (ap < 0.01159){
        return horner(p, qq+14, 7);
    }else if (ap < 0.0766){
        return horner(p, qq+10, 11);
    }else{
        return horner(p, qq, 21);
    }
  }
inline double LambertW0ZeroSeries(double z)
{
    static const double qq[17]={136808.86090394293563, -55103.621972903835338, 22324.308512706601434, -9104.5002411580189358, 3741.4497029592385495, -1551.1605194805194805, 
                            649.78717234347442681, -275.57319223985890653, 118.62522321428571429, -52.012698412698412698, 23.343055555555555556, -10.8, 5.2083333333333333333,
                            -2.6666666666666666667, 1.5, -1, 1};
    return z*horner(z, qq, 17);
}

inline double FinalResult(double w, double y)
{
    double f0 = w - y;
    double f1 = 1 + y;
    double f00 = f0 * f0;
    double f11 = f1 * f1;
    double f0y = f0 * y;
    return w - 4.0 * f0 * fma(6.0 * f1, (f11 + f0y), f00 * y) / fma(f00, fma(fma(8.0, f1, 6.0 * y), y, f0y), f11 * fma(36.0, f0y, 24.0 * f11));
}

double unsafe_lambertw0(double z)
{
    static const double e[66] = { 2.718281828459045, 1.0, 0.36787944117144233, 0.1353352832366127, 0.049787068367863944, 0.01831563888873418, 0.006737946999085467, 
                            0.0024787521766663585, 0.0009118819655545162, 0.00033546262790251185, 0.00012340980408667956, 4.5399929762484854e-05, 1.670170079024566e-05,
                            6.14421235332821e-06, 2.2603294069810542e-06, 8.315287191035679e-07, 3.059023205018258e-07, 1.1253517471925912e-07, 4.139937718785167e-08, 
                            1.522997974471263e-08, 5.602796437537268e-09, 2.061153622438558e-09, 7.582560427911907e-10, 2.7894680928689246e-10, 1.026187963170189e-10,
                            3.775134544279098e-11, 1.3887943864964021e-11, 5.109089028063325e-12, 1.8795288165390832e-12, 6.914400106940203e-13, 2.543665647376923e-13, 
                            9.357622968840175e-14, 3.442477108469977e-14, 1.2664165549094176e-14, 4.658886145103398e-15, 1.713908431542013e-15, 6.305116760146989e-16, 
                            2.3195228302435696e-16, 8.533047625744066e-17, 3.1391327920480296e-17, 1.1548224173015786e-17, 4.248354255291589e-18, 1.5628821893349888e-18, 
                            5.74952226429356e-19, 2.1151310375910805e-19, 7.781132241133797e-20, 2.8625185805493937e-20, 1.0530617357553812e-20, 3.873997628687187e-21, 
                            1.4251640827409352e-21, 5.242885663363464e-22, 1.9287498479639178e-22, 7.095474162284704e-23, 2.6102790696677047e-23, 9.602680054508676e-24, 
                            3.532628572200807e-24, 1.2995814250075031e-24, 4.780892883885469e-25, 1.7587922024243116e-25, 6.47023492564546e-26, 2.3802664086944007e-26, 
                            8.75651076269652e-27, 3.221340285992516e-27, 1.185064864233981e-27, 4.359610000063081e-28, 1.603810890548638e-28};
    static const double g[65] = { 0.0, 2.718281828459045, 14.7781121978613, 60.256610769563004, 218.39260013257694, 742.065795512883, 2420.5727609564105, 7676.43210899921, 
                                23847.663896333826, 72927.75534817846, 220264.65794806718, 658615.558867176, 1953057.497028047, 5751374.096115966, 16836459.978306875, 
                                49035260.58708166, 142177768.32812595, 410634196.81078005, 1181879444.471949, 3391163718.300558, 9703303908.195807, 27695130424.14751, 78868082614.89502, 
                            224130479263.72476, 635738931116.2433, 1800122483434.6467, 5088969845149.808, 14365302496248.562, 40495197800161.305, 114008694617177.22, 320594237445733.9, 
                            900514339622670.1, 2526814725845782.0, 7083238132935230.0, 19837699245933464.0, 55510470830970072.0, 155204335696147040.0, 433608267793696640.0, 
                            1210525406770322688.0, 3377142616535756288.0, 9415410673480800256.0, 26233583234732253184.0, 73049547543861043200.0, 203297097133861896192.0, 
                            565470405031809581056.0, 1572042197586829377536.0, 4368214933477126569984.0, 1.2132170565093316e+22, 3.3680332378068633e+22, 9.345998205225989e+22, 
                            2.592352764293536e+23, 7.187680320377388e+23, 1.9921241603726199e+24, 5.519292499505416e+24, 1.5286067837683348e+25, 4.232131895828109e+25, 
                            1.1713293177672778e+26, 3.240860399621482e+26, 8.964125826422603e+26, 2.4787141382364034e+27, 6.852044338894106e+27, 1.8936217407781712e+28, 
                            5.231781134619702e+28, 1.4450833904658542e+29, 3.990495411719435e+29};
    static const double a[12] = { 0.6065306597126334, 0.7788007830714049, 0.8824969025845955, 0.9394130628134758, 0.9692332344763441, 0.9844964370054085, 0.9922179382602435, 
                            0.9961013694701175, 0.9980487811074755, 0.9990239141819757, 0.9995118379398894, 0.9997558891748972};
    static const double b[12] = { 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 0.0009765625, 0.00048828125, 0.000244140625};

    if (abs(z) < 0.05)
        return LambertW0ZeroSeries(z);
    if (z < -0.35) {
        double p2 = 2 * (M_E * z + 1);
        if (p2 > 0)
            return LambertWSeries(sqrt(p2));
        if (p2 == 0)
            return -1;
    }
    int n;
    for (n = 0; n <= 2; n++){
        if (g[n] > z)
            goto line1;
    }
    n--;
    for (int j = 1; j <= 5; j++) {
        n *= 2;
        if (g[n] > z)
            goto line2;
    }
    return 0.0/0.0;
line2:
    {
        int nh = n / 2;
        for (int j = 1; j <= 5; ++j) {
            nh /= 2;
            if (nh <= 0)
                break;
            if (g[n-nh] > z)
                n -= nh;
        }
    }
line1:
    n--;
    int jmax = 8;
    if (z <= -0.3)
        jmax = 11;
    else if (n <= 0)
        jmax = 10;
    else if (n <= 1)
        jmax = 9;
    double y = z * e[n+1];
    double w = n;
    for (int j = 0; j < jmax; ++j) {
        double wj = w + b[j];
        double yj = y * a[j];
        if (wj < yj) {
            w = wj;
            y = yj;
        }
    }
    return FinalResult(w, y);
}


double unsafe_lambertw1(double z)
{
    static const double e[64] = {2.718281828459045, 7.3890560989306495, 20.085536923187664, 54.59815003314423, 148.41315910257657, 403.428793492735, 1096.6331584284583, 
                        2980.957987041727, 8103.08392757538, 22026.465794806703, 59874.14171519778, 162754.79141900383, 442413.3920089202, 1202604.2841647759, 
                        3269017.372472108, 8886110.520507865, 24154952.753575277, 65659969.13733045, 178482300.96318707, 485165195.40978974, 1318815734.4832132, 
                        3584912846.1315875, 9744803446.24889, 26489122129.843437, 72004899337.38577, 195729609428.8385, 532048240601.79785, 1446257064291.473, 
                        3931334297144.036, 10686474581524.445, 29048849665247.38, 78962960182680.56, 214643579785915.7, 583461742527453.9, 1586013452313427.8, 
                        4311231547115187.0, 11719142372802588.0, 31855931757113692.0, 86593400423993568.0, 235385266837019488.0, 639843493530053504.0, 1739274941520497152.0, 
                        4727839468229336064.0, 12851600114359277568.0, 34934271057485012992.0, 94961194206024253440.0, 258131288619006099456.0, 701673591209761439744.0, 
                        1907346572495094808576.0, 5.184705528587058e+21, 1.4093490824269349e+22, 3.831008000716566e+22, 1.0413759433029058e+23, 2.830753303274686e+23, 
                        7.694785265141995e+23, 2.09165949601299e+24, 5.685719999335915e+24, 1.5455389355900992e+25, 4.201210403790501e+25, 1.1420073898156806e+26, 
                        3.1042979357019096e+26, 8.438356668741426e+26, 2.2937831594696023e+27, 6.235149080811596e+27};
    static const double g[64] = {-0.36787944117144233, -0.2706705664732254, -0.14936120510359183, -0.07326255555493671, -0.03368973499542734, -0.014872513059998151, 
                        -0.006383173758881614, -0.002683701023220095, -0.001110688236780116, -0.0004539992976248485, -0.00018371870869270227, -7.373054823993851e-05,
                        -2.9384282290753705e-05, -1.164140206744995e-05, -4.588534807527387e-06, -1.8005627955081459e-06, -7.037894121934784e-07, -2.741396354048273e-07, 
                        -1.0645313231320808e-07, -4.122307244877116e-08, -1.5923376898615004e-08, -6.136829804311634e-09, -2.3602323152914347e-09, -9.060322906269835e-10, 
                        -3.471985966241005e-10, -1.3283631472964644e-10, -5.074727804655525e-11, -1.936032029943257e-11, -7.376630377393076e-12, -2.8072868906520526e-12, 
                        -1.0671679036256928e-12, -4.052532975710136e-13, -1.5374324278841212e-13, -5.827288667242844e-14, -2.2067908660514462e-14, -8.35028218887685e-15, 
                        -3.1572276215253042e-15, -1.1928704609782513e-15, -4.503807427476156e-16, -1.6993417021166355e-16, -6.407816976273453e-17, -2.4147993510032952e-17, 
                        -9.095063461641647e-18, -3.4236981860988703e-18, -1.2881333612472272e-18, -4.844083984474754e-19, -1.820778885482978e-19, -6.840787597156489e-20, 
                        -2.5690139750480974e-20, -9.643749239819589e-21, -3.6186918227651994e-21, -1.3573451162272066e-21, -5.089420428889598e-22, -1.9076194289884357e-22, 
                        -7.147697837541266e-23, -2.677300014975863e-23, -1.0025115553818576e-23, -3.752736256874367e-24, -1.4043571811296964e-24, -5.253906457617913e-25, 
                        -1.9650175744554348e-25, -7.347402158250682e-26, -2.746554300039741e-26, -1.0264389699511283e-26};
    static const double a[12] = {1.6487212707001282, 1.2840254166877414, 1.1331484530668263, 1.0644944589178593, 1.0317434074991028, 1.0157477085866857, 1.007843097206448,
                        1.0039138893383475, 1.0019550335910028, 1.0009770394924165, 1.0004884004786945, 1.0002441704297478};
    static const double b[12] = {0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 0.0009765625, 0.00048828125, 0.000244140625};

    if (z >= 0) {
        return 0.0/0.0;
    }
    if (z < -0.35) {
        const double p2 = 2 * (M_E * z + 1);
        if (p2 > 0)
            return LambertWSeries(-sqrt(p2));
        if (p2 == 0)
            return -1;
        return 0.0/0.0;
    }
    int n = 2;
    if (g[n - 1] > z)
        goto line1;
    for (int j = 1; j <= 5; ++j) {
        n *= 2;
        if (g[n - 1] > z)
            goto line2;
    }
    return 0.0/0.0;
line2:
    {
        int nh = n / 2;
        for (int j = 1; j <= 5; ++j) {
        nh /= 2;
        if (nh <= 0)
            break;
        if (g[n-nh - 1] > z)
            n -= nh;
        }
    }
line1:
    --n;
    int jmax = 11;
    if (n >= 8)
        jmax = 8;
    else if (n >= 3)
        jmax = 9;
    else if (n >= 2)
        jmax = 10;
    double w = -n;
    double y = z * e[n - 1];
    for (int j = 0; j < jmax; ++j) {
        const double wj = w - b[j];
        const double yj = y * a[j];
        if (wj < yj) {
            w = wj;
            y = yj;
        }
    }
    return FinalResult(w, y);
}
}