#include "../../headers/math.hpp"
#include <cfloat>
#include <cmath>
#include <cstdint>
#include <cstring>

double horner(double x, double *coefs, uint_fast8_t n)
{
    double val = coefs[0];
    for (uint_fast8_t k = 1; k < n; k++) {
        val = fma(x, val,  coefs[k]);
    }
    return val;
}

double horner1(double x, double* coefs, uint_fast8_t n)
{
    double val = x + coefs[0];
    for (uint_fast8_t k = 1; k < n; k++) {
        val = fma(x, val, coefs[k]);
    }
    return val;
}

namespace krcrand{

double uniform01_exclude0(uint64_t a)
{
    return fma(double(a), 5.4210108624275221703e-20, 5.4210108624275221700e-20);
}

// The code for log function below is based on algorithm from Cephes 2.8 math library by 
// Stephen L. Moshier 1984, 1995, 2000 - http://www.netlib.org/cephes/
// Max relative error is 1.523918708144333e-16 for normal numbers and 1.039444891344354e-16
// for subnormals (10^10 test runs).
double unsafe_log(double x)
{
    //Subnormal numbers correction. Max rel. error is 1.039444891344354e-16 for 10^10 test runs.
    double addition = 0;
    if (x <= 2.2250738585072009e-308) {
        x *= 4503599627370496.0;
        addition = -36.0436533891171560897;
    }
    //x=2.2e-308
    // Log(2)
    const double loge2_p = 0.693359375;
    const double loge2_n = 2.121944400546905827679E-4;
    //const double loge2 = 0.693147180559945309417;
    //sqrt(2)/2
    const double sqrt2b2 = 7.07106781186547524400E-1;
    //Constants for polynom
    double a[6] = { 1.01875663804580931796E-4, 4.97494994976747001425E-1, 4.70579119878881725854E0, 1.44989225341610930846E1, 1.79368678507819816313E1,   7.70838733755885391666E0 };
    double b[6] = { 1.12873587189167450590E1, 4.52279145837532221105E1, 8.29875266912776603211E1, 7.11544750618563894466E1, 2.31251620126765340583E1 };// first cooficient is 1 here
    // unpack double
    uint64_t code;
    memcpy(&code, &x, sizeof(double));
    uint64_t man_code = (code & 0x000FFFFFFFFFFFFF) | 0x3FE0000000000000;
    uint64_t exp_code = code >> 52 | 0x4330000000000000;
    double man;
    double exp;
    memcpy(&man, &man_code, sizeof(double));
    memcpy(&exp, &exp_code, sizeof(double));
    exp = exp - 1022 - 4503599627370496.0;
    // Fix interval
    if (man < sqrt2b2) {
        man += man;
        exp--;
    }
    man -= 1;
    //Rational approximation
    double num = horner(man, a, 6);
    double den = horner1(man, b, 5);

    double man2 = man * man;

    double res = fma(man, (man2 * num / den), -loge2_n * exp);
    //Splitting increases precision:
    //res -= loge2_n * exp;
    res = fma(-0.5, man2, res);
    //res -= 0.5 * man2;
    res += man;
    //res += loge2 * exp; Using property of logarithms for powers.
    //res += loge2_p * exp;
    res = fma(loge2_p, exp, res);
    return res + addition;
}


/* The code below for LambertW0 function is based on Darko Veberic realization of method from
  Toshio Fukushima, "Precise and fast computation of Lambert W-functions without transcendental 
  function evaluations", J. Comp. Appl. Math. 244 (2013) 77-89. The author distributes it under 
  the terms of the BSD-2 clause license.*/
double LambertWSeries(const double p)
  {
    static const double q[] = { -1.0, 1.0, -0.333333333333333333, 0.152777777777777778, -0.0796296296296296296, 0.0445023148148148148, -0.0259847148736037625, 0.0156356325323339212,
                                -0.00961689202429943171, 0.00601454325295611786, -0.00381129803489199923, 0.00244087799114398267, -0.00157693034468678425, 0.00102626332050760715,
                                -0.000672061631156136204, 0.000442473061814620910, -0.000292677224729627445, 0.000194387276054539318, -0.000129574266852748819,
                                0.0000866503580520812717, -0.0000581136075044138168};
    const double ap = abs(p);
    if (ap < 0.01159)
      return
        -1 +
        p*(1 +
        p*(q[2] +
        p*(q[3] +
        p*(q[4] +
        p*(q[5] +
        p*q[6]
        )))));
    else if (ap < 0.0766)
      return
        -1 +
        p*(1 +
        p*(q[2] +
        p*(q[3] +
        p*(q[4] +
        p*(q[5] +
        p*(q[6] +
        p*(q[7] +
        p*(q[8] +
        p*(q[9] +
        p*q[10]
        )))))))));
    else
      return
        -1 +
        p*(1 +
        p*(q[2] +
        p*(q[3] +
        p*(q[4] +
        p*(q[5] +
        p*(q[6] +
        p*(q[7] +
        p*(q[8] +
        p*(q[9] +
        p*(q[10] +
        p*(q[11] +
        p*(q[12] +
        p*(q[13] +
        p*(q[14] +
        p*(q[15] +
        p*(q[16] +
        p*(q[17] +
        p*(q[18] +
        p*(q[19] +
        p*q[20]
        )))))))))))))))))));
  }
inline double LambertW0ZeroSeries(double z)
{
    return
        z*(1 -
        z*(1 -
        z*(1.5 -
        z*(2.6666666666666666667 -
        z*(5.2083333333333333333 -
        z*(10.8 -
        z*(23.343055555555555556 -
        z*(52.012698412698412698 -
        z*(118.62522321428571429 -
        z*(275.57319223985890653 -
        z*(649.78717234347442681 -
        z*(1551.1605194805194805 -
        z*(3741.4497029592385495 -
        z*(9104.5002411580189358 -
        z*(22324.308512706601434 -
        z*(55103.621972903835338 -
        z*136808.86090394293563
        ))))))))))))))));
}

inline double FinalResult(double w, double y)
{
    double f0 = w - y;
    double f1 = 1 + y;
    double f00 = f0 * f0;
    double f11 = f1 * f1;
    double f0y = f0 * y;
    return w - 4.0 * f0 * (6.0 * f1 * (f11 + f0y) + f00 * y) /
           (f11 * (24.0 * f11 + 36.0 * f0y) + f00 * (6.0 * y * y + 8.0 * f1 * y + f0y));
}

// Only for z > -0.35
// max relative error is 1.587675183130534e-15 in range [-0.35, 10^4] (10^9 runs).
double unsafe_lambertw0(double z)
  {
    double e[66] = { 2.718281828459045, 1.0, 0.36787944117144233, 0.1353352832366127, 0.049787068367863944, 0.01831563888873418, 0.006737946999085467, 0.0024787521766663585,
                    0.0009118819655545162, 0.00033546262790251185, 0.00012340980408667956, 4.5399929762484854e-05, 1.670170079024566e-05, 6.14421235332821e-06,
                    2.2603294069810542e-06, 8.315287191035679e-07, 3.059023205018258e-07, 1.1253517471925912e-07, 4.139937718785167e-08, 1.522997974471263e-08,
                    5.602796437537268e-09, 2.061153622438558e-09, 7.582560427911907e-10, 2.7894680928689246e-10, 1.026187963170189e-10, 3.775134544279098e-11,
                    1.3887943864964021e-11, 5.109089028063325e-12, 1.8795288165390832e-12, 6.914400106940203e-13, 2.543665647376923e-13, 9.357622968840175e-14,
                    3.442477108469977e-14, 1.2664165549094176e-14, 4.658886145103398e-15, 1.713908431542013e-15, 6.305116760146989e-16, 2.3195228302435696e-16,
                    8.533047625744066e-17, 3.1391327920480296e-17, 1.1548224173015786e-17, 4.248354255291589e-18, 1.5628821893349888e-18, 5.74952226429356e-19,
                    2.1151310375910805e-19, 7.781132241133797e-20, 2.8625185805493937e-20, 1.0530617357553812e-20, 3.873997628687187e-21, 1.4251640827409352e-21,
                    5.242885663363464e-22, 1.9287498479639178e-22, 7.095474162284704e-23, 2.6102790696677047e-23, 9.602680054508676e-24, 3.532628572200807e-24,
                    1.2995814250075031e-24, 4.780892883885469e-25, 1.7587922024243116e-25, 6.47023492564546e-26, 2.3802664086944007e-26, 8.75651076269652e-27,
                    3.221340285992516e-27, 1.185064864233981e-27, 4.359610000063081e-28, 1.603810890548638e-28};
    double g[65] = { 0.0, 2.718281828459045, 14.7781121978613, 60.256610769563004, 218.39260013257694, 742.065795512883, 2420.5727609564105, 7676.43210899921, 
                    23847.663896333826, 72927.75534817846, 220264.65794806718, 658615.558867176, 1953057.497028047, 5751374.096115966, 16836459.978306875, 49035260.58708166,
                    142177768.32812595, 410634196.81078005, 1181879444.471949, 3391163718.300558, 9703303908.195807, 27695130424.14751, 78868082614.89502, 224130479263.72476,
                    635738931116.2433, 1800122483434.6467, 5088969845149.808, 14365302496248.562, 40495197800161.305, 114008694617177.22, 320594237445733.9, 900514339622670.1,
                    2526814725845782.0, 7083238132935230.0, 19837699245933464.0, 55510470830970072.0, 155204335696147040.0, 433608267793696640.0, 1210525406770322688.0,
                    3377142616535756288.0, 9415410673480800256.0, 26233583234732253184.0, 73049547543861043200.0, 203297097133861896192.0, 565470405031809581056.0, 
                    1572042197586829377536.0, 4368214933477126569984.0, 1.2132170565093316e+22, 3.3680332378068633e+22, 9.345998205225989e+22, 2.592352764293536e+23, 
                    7.187680320377388e+23, 1.9921241603726199e+24, 5.519292499505416e+24, 1.5286067837683348e+25, 4.232131895828109e+25, 1.1713293177672778e+26, 
                    3.240860399621482e+26, 8.964125826422603e+26, 2.4787141382364034e+27, 6.852044338894106e+27, 1.8936217407781712e+28, 5.231781134619702e+28, 
                    1.4450833904658542e+29, 3.990495411719435e+29};
    double a[12] = { 0.6065306597126334, 0.7788007830714049, 0.8824969025845955, 0.9394130628134758, 0.9692332344763441, 0.9844964370054085, 0.9922179382602435, 
                    0.9961013694701175, 0.9980487811074755, 0.9990239141819757, 0.9995118379398894, 0.9997558891748972};
    double b[12] = { 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.001953125, 0.0009765625, 0.00048828125, 0.000244140625};

    if (abs(z) < 0.05)
        return LambertW0ZeroSeries(z);
    if (z < -0.35) {
        double p2 = 2 * (M_E * z + 1);
        if (p2 > 0)
            return LambertWSeries(sqrt(p2));
        if (p2 == 0)
            return -1;
    }
    int n;
    for (n = 0; n <= 2; ++n)
        if (g[n] > z)
            goto line1;
    n = 2;
    for (int j = 1; j <= 5; ++j) {
        n *= 2;
        if (g[n] > z)
            goto line2;
    }
    return 0.0/0.0;
line2:
    {
        int nh = n / 2;
        for (int j = 1; j <= 5; ++j) {
            nh /= 2;
            if (nh <= 0)
                break;
            if (g[n-nh] > z)
                n -= nh;
        }
    }
line1:
    n--;
    int jmax = 8;
    if (z <= -0.3)
        jmax = 11;
    else if (n <= 0)
        jmax = 10;
    else if (n <= 1)
        jmax = 9;
    double y = z * e[n+1];
    double w = n;
    for (int j = 0; j < jmax; ++j) {
        double wj = w + b[j];
        double yj = y * a[j];
        if (wj < yj) {
            w = wj;
            y = yj;
        }
    }
    return FinalResult(w, y);
  }
}